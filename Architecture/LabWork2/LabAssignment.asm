; -------------------------------------------------------------------------------------	;
;	Лабораторная работа №2 по курсу Программирование на языке ассемблера				;
;	Вариант №3.3																		;
;	Выполнил студент Екатерина Камкова (student 14).									;
;																						;
;	Исходный модуль LabAssignment														;
;	Содержит функции на языке ассемблера, разработанные в соответствии с заданием		;
; -------------------------------------------------------------------------------------	;
;	Задание: Реализовать функции вычисления синдромов и восстановления
;		утраченных дисков в массиве RAID-6
;	Размер блока - 32 байта
;	Общее количество блоков в страйпе N+2:
;		0...N-1 - блоки данных
;		N		- синдром P
;		N+1		- миндром Q
;	Поле Галуа, используемое для вычислений: G(2^32)
;	Технология, используемая при реализации: ??

.DATA
	; для следующих двух констант использую qword, 
	; потому что c переменными yword и массивами из oword
	; не компилируется

	; модуль, по которому построено поле, без старшего бита 
	ModuloMask qword 0000008D0000008Dh, 0000008D0000008Dh, 0000008D0000008Dh, 0000008D0000008Dh

	; маска для очистки младших битов каждого байта
	LowOderBitMask qword 0FFFFFFFEFFFFFFFEh, 0FFFFFFFEFFFFFFFEh, 0FFFFFFFEFFFFFFFEh, 0FFFFFFFEFFFFFFFEh

	degreeTable dd 80000046h,  40000023h,  0A0000057h, 0D000006Dh,    ; массив степеней x = 2 от -1 до -30
				   0E8000070h, 74000038h,  3A00001Ch,  1D00000Eh,	 
				   0E800007h,  87400045h,  0C3A00064h, 61D00032h,
			       30E80019h,  9874004Ah,  4C3A0025h,  0A61D0054h,
				   530E802Ah,  29874015h,  94C3A04Ch,  4A61D026h,
				   2530E813h,  9298744Fh,  0C94C3A61h, 0E4A61D76h,
				   72530EBBh,  0B929871Bh, 0DC94C3CBh, 0EE4A61A3h, 0F7253097h, 0FB92980Dh

	dividerTable dd 0FFFFFF85h, 5555557Dh, 924924DCh, 044444464h,	  ; массив (1 - x^(a-b))^(-1) от -1 до -30
					9CE73987h, 0CB2CB2AAh, 76EDDB8Fh, 0C8C8C8A8h,
				    9FCFE7BBh, 0E3F8FE4Bh, 0DA1B431h, 0F4FF4F8Bh,
				    3C69E351h, 3288CA3Ah,  2AFA55E1h, 0E32BE35Fh,
				    7F4FBF9Bh, 0B017EC5Bh, 5B426B47h, 0F3C40F40h,
				    9935D482h, 6E2C718Ch,  0B5864737h, 31AC5529h,
				    74E9D383h, 0C69FD7D6h, 75459857h, 0EB53671Eh, 0C5A67F60h, 44C5D6Fh

.CODE

; ------------------------------------------------------------------------------------- ;
; Умножение многочлена на x																;
; 
; ------------------------------------------------------------------------------------- ;

MultiplyX MACRO

	;---создание маски модулей---;

	vpxor ymm4, ymm4, ymm4			; обнуляем для последующего сравнения
	vpcmpgtd ymm4, ymm4, ymm1		; элементы ymm1, соответствующие отрицательным 
									; (т.е. где бит, соответствующий знаку == 1)
									; устанавливаются в FF, остальные обнуляются
	vpand ymm4, ymm4, ymm3		    ; маска модулей для элементов со старшим битом = 1


	;---сдвиг на 1 бит влево---;

	vpslld ymm1, ymm1, 1			; сдвиг влево пословно (в данном случае по dword)
	vpand ymm1, ymm1, ymm2			; очистка битов межбайтного переноса
	vpxor ymm1, ymm1, ymm4			; добавление модуля

ENDM


; ------------------------------------------------------------------------------------- ;
; Вычисление P и Q                                                                      ; 
; ------------------------------------------------------------------------------------- ;

CountPQ MACRO 
	local @l1

	mov rax, rcx						; сохранение адреса страйпа
	mov rcx, rdx			 			; rcx станет счётчиком в следующем цикле, 
	dec rcx	

	vmovdqu ymm0, ymmword ptr [rax]		; запись первого блока данных в ymm0 для P
										; без выравнивания, потому что изначально данные не выровнены
	vmovdqu ymm1, ymmword ptr [rax]		; запись первого блока данных в ymm1 для Q

	mov r10, rax						; при помощи r10 будем перемещаться по блокам
	add r10, 32							; сразу перемещаемся на второй блок

	mov r11, offset LowOderBitMask		; достаём LowOderBitMask
	vmovdqu ymm2, ymmword ptr [r11]

	mov r11, offset ModuloMask			; достаём ModuloMask
	vmovdqu ymm3, ymmword ptr [r11]


@l1:									; вычисление P и Q
	; P
		vpxor ymm0, ymm0, [r10]			; xor со следующим блоком для P

	; Q
		MultiplyX						; умножаем на x
		vpxor ymm1, ymm1, [r10]			; xor со следующим блоком

		add r10, 32						; перемещаемся на блок вперед
		loop @l1

ENDM


; -------------------------------------------------------------------------------------	;
; Умножение двух многочленов															;
; -------------------------------------------------------------------------------------	;

MultiplyPolynoms MACRO
	local @mult, @devBit1, @devBit2, @resultBit1, @resultBit2 

	vpxor ymm5, ymm5, ymm5			; здесь будет произведениe
	mov rcx, 31						; (1) умножаем 32 битное число => необходимы 31 операция (sum + y) * 10
									; (2) и ещё одна операция sum + y

@mult:								; (1)
		sal r11d, 1					; сдвигаем влево b (второй множитель)
		jnc @devBit1				; если странший бит был 1,
		vpxor ymm5, ymm5, ymm1		; добавляем к аккумулятору а
	@devBit1:						; далее необходимо умножить на х = 10	
	
		;---Та же функция умножения на х, что MultiplyX, только первый множитель - ymm5, а не ymm1---;
		vpxor ymm4, ymm4, ymm4			
		vpcmpgtd ymm4, ymm4, ymm5		 
		vpand ymm4, ymm4, ymm3		
		vpslld ymm5, ymm5, 1		
		vpand ymm5, ymm5, ymm2		
		vpxor ymm5, ymm5, ymm4		

		loop @mult

	sal r11d, 1						; (2) сдвигаем влево b 
	jnc @devBit2					; если странший бит был 1,
	vpxor ymm5, ymm5, ymm1			; добавляем к аккумулятору а

@devBit2:

ENDM



; -------------------------------------------------------------------------------------	;
; void CalculateSyndromes(void *D, unsigned int N)										;
;	Вычисление синдромов P и Q															;
;	D - Адрес страйпа, N - количество дисков данных										;
; -------------------------------------------------------------------------------------	;

CalculateSyndromes PROC		; [RCX] - D
							; RDX   - N

	CountPQ								; Считаем P и Q

	vmovdqu ymmword ptr [r10], ymm0		; записываем P в память
	vmovdqu ymmword ptr [r10+32], ymm1  ; записываем Q сразу за P
	
	ret						
CalculateSyndromes ENDP



; -------------------------------------------------------------------------------------	;
; void Recover(void *D, unsigned int N, unsigned int a, unsigned int b)					;
;	Восстановление блоков с номерами a и b (b>a)										;
;	D - Адрес страйпа, N - количество дисков данных										;
; -------------------------------------------------------------------------------------	;
Recover PROC	; [RCX] - D
				; RDX   - N
				; R8	- a
				; R9	- b

	push r12
	mov r12, rdx

;---------------Достаю из таблицы элемент (1 - x^(a-b))^(-1)---------------;

	mov r10, r9									; считаем значение b - a, чтобы узнать номер элемента
	sub r10, r8									; в таблице dividerTable

	dec r10										; надо перепрыгнуть (b-a) - 1 элементов, чтобы добраться до значения (1 - x^(a-b))^(-1)
	mov rax, 4									; размер элемента - 32 байта
	mul r10										; получаем количество ячеек памяти, кот. надо перепрыгнуть

	mov r11, offset dividerTable				; находим адрес первого элемента в таблице 
	mov r10d, [r11 + rax]						; загружаем нужный нам элемент
	push r10


;---------------Достаю из таблицы элемент x^(a-N+1)---------------;

	mov r10, r12								; считем значение N - 1 - a, чтобы узнать номер элемента
	dec r10										; в таблице degreeTable
	sub r10, r8						
	
	dec r10										; надо перепрыгнуть (N-1-a) - 1 элементов, чтобы добраться до значения x^(a-N+1)
	mov rax, 4									; размер элемента - 32 байта
	mul r10										; получаем количество ячеек памяти, кот. надо перепрыгнуть

	mov r11, offset degreeTable					; находим адрес первого элемента в таблице 
	mov r11d, [r11 + rax]						; загружаем нужный нам элемент

	pop r10
	mov rdx, r12
	pop r12

	push rcx
	push r10
	push r11

;---------------Рассчёт Da и Db--------------------;

;---------------Считаем P' u Q'---------------;

	CountPQ									; считаем P и Q

	vpxor ymm0, ymm0, [r10]					; ксорим новые P и Q cо старыми P и Q, получаем P', Q' 
	vpxor ymm1, ymm1, [r10+32]

	pop r11
	pop r10

	; на данный момент ymm0 = P'
	;				   ymm1 = Q'
	;				   ymm2 = LowOderBitMask
	;				   ymm3 = ModuloMask
	;				   r10  = (1 - x^(a-b))^(-1)
	;				   r11  = x^(a-N+1)

	
;---------------Умножение Q' на x^(a-N+1)---------------;

	MultiplyPolynoms				; Умножаем ymm1 на r11
	vmovdqu ymm1, ymm5				; Перемещаем Q' * x^(a-N+1)
	

;---------------Вычисление P' - Q' * x^(a-N+1)---------------;

	vpxor ymm1, ymm1, ymm0 


;---------------Умножение P' - Q' * x^(a-N+1) на (1 - x^(a-b))^(-1) = Db----------------;

	mov r11, r10
	MultiplyPolynoms						; Умножаем ymm1 на r11

	pop rcx
	mov rax, 32								; найдём необходимый сдвиг
	mov r10, rdx							; mul меняет rdx, поэтому сохраним rdx в r10
	mul r9	
	vmovdqu ymmword ptr [rcx + rax], ymm5	; помещаем (P' - Q' * x^(a-N+1)) * (1 - x^(a-b))^(-1) = Db на место Db


;---------------Рассчет Da = P' - Db----------------;

	vpxor ymm5, ymm5, ymm0					; вычисляем Da
	
	mov rax, 32								; найдём необходимый сдвиг
	mul r8									; приходится помещать rdx в стэк
	vmovdqu ymmword ptr [rcx + rax], ymm5	; помещаем P' - Db на место Da

	ret
Recover ENDP
END



