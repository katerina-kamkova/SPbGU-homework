; -------------------------------------------------------------------------------------	;
;	Лабораторная работа №1 по курсу Программирование на языке ассемблера				;
;	Вариант №3.3																		;
;	Выполнил студент Екатерина Камкова (student 14).									;
;																						;
;	Исходный модуль LabAssignment														;
;	Содержит функции на языке ассемблера, разработанные в соответствии с заданием		;
; -------------------------------------------------------------------------------------	;
;	Задание: Реализовать функции вычисления синдромов и восстановления
;		утраченных дисков в массиве RAID-6
;	Размер блока - 32 байта
;	Общее количество блоков в страйпе N+2:
;		0...N-1 - блоки данных
;		N		- синдром P
;		N+1		- миндром Q
;	Поле Галуа, используемое для вычислений: G(2^32)
;	Технология, используемая при реализации: ??

.DATA

	degreeTable dd 80000046h,  40000023h,  0A0000057h, 0D000006Dh,    ; массив степеней x = 2 от -1 до -30
				   0E8000070h, 74000038h,  3A00001Ch,  1D00000Eh,	 
				   0E800007h,  87400045h,  0C3A00064h, 61D00032h,
			       30E80019h,  9874004Ah,  4C3A0025h,  0A61D0054h,
				   530E802Ah,  29874015h,  94C3A04Ch,  4A61D026h,
				   2530E813h,  9298744Fh,  0C94C3A61h, 0E4A61D76h,
				   72530EBBh,  0B929871Bh, 0DC94C3CBh, 0EE4A61A3h, 0F7253097h, 0FB92980Dh

	dividerTable dd 0FFFFFF85h, 5555557Dh, 924924DCh, 44444464h,	  ; массив (1 - x^(a-b))^(-1) от -1 до -30
					9CE73987h, 0CB2CB2AAh, 76EDDB8Fh, 0C8C8C8A8h,
				    9FCFE7BBh, 0E3F8FE4Bh, 0DA1B431h, 0F4FF4F8Bh,
				    3C69E351h, 3288CA3Ah, 2AFA55E1h, 0E32BE35Fh,
				    7F4FBF9Bh, 0B017EC5Bh, 5B426B47h, 0F3C40F40h,
				    9935D482h, 6E2C718Ch, 0B5864737h, 31AC5529h,
				    74E9D383h, 0C69FD7D6h, 75459857h, 0EB53671Eh, 0C5A67F60h, 44C5D6Fh

.CODE

; -------------------------------------------------------------------------------------	;
; Умножение двух многочленов															;
; -------------------------------------------------------------------------------------	;

Multiply MACRO
	local @mult, @devBit1, @devBit2, @resultBit1, @resultBit2 

	xor r14d, r14d						; здесь будут произведения
	xor r15d, r15d

	mov rcx, 31						; (1) умножаем 32 битное число => необходимы 31 операция (sum + y) * 10
									; (2) и ещё одна операция sum + y

@mult:								; (1)
		sal eax, 1					; сдвигаем влево b (второй множитель)
		jnc @devBit1				; если странший бит был 1,
		xor r14d, r10d				; добавляем к аккумуляторам соответствующие экземпляры а
		xor r15d, r11d
	@devBit1:						; далее необходимо умножить на х = 10					
		sal r14d, 1					; как в прошлой функции: сдвиг влево
		jnc @resultBit1				; проверяем, каким был старший бит
		xor r14d, esi				; при необходимости складываем с esi
	@resultBit1:
		sal r15d, 1					
		jnc @resultBit2				
		xor r15d, esi		
	@resultBit2:

		loop @mult

	sal eax, 1						; (2) сдвигаем влево b 
	jnc @devBit2					; если странший бит был 1,
	xor r14d, r10d					; добавляем к аккумуляторам соответствующие экземпляры а
	xor r15d, r11d
@devBit2:

ENDM


; -------------------------------------------------------------------------------------	;
; Поиск двух слов Da и Db, а также их запись в память									;
;	plus - сдвиг, чтобы определить, какие по счёту 2 слова								;
; -------------------------------------------------------------------------------------	;

CountDaDb MACRO plus
	local @countPAndQ, @c1, @c2

	;---------------Начальные установки---------------;

	mov rdi, rbx
	add rdi, plus

	mov r8d, [rdi]			; первые 2 слова блока D0 для подсчета нового P
	mov r9d, [rdi+4]		
	mov r10d, r8d			; первые 2 слова блока D0 для подсчета нового Q
	mov r11d, r9d		

	mov rcx, rdx			; установим счётчик на N-1
	dec rcx

	add rdi, 32				; адрес D1


;---------------Подсчёт новых P и Q----------------;

@countPAndQ:				; посчитаем новые P и Q
	
		xor r8d, [rdi]		; сложение со следующим D
		xor r9d, [rdi+4]

		sal r10d, 1			; сдвиг влево
		jnc @c1				; если старший бит был равен 1
		xor r10d, esi		; сложение с порождающим многочленом
	@c1:
		sal r11d, 1
		jnc @c2
		xor r11d, esi
	@c2:
		xor r10d, [rdi]		; сложение со следующим D
		xor r11d, [rdi+4]

		add rdi, 32			; переходим к следующему D

		loop @countPAndQ


;---------------Подсчёт P' и Q'----------------;

	xor r8d, [rdi]			; P' - P (в поле Галуа = P - P')
	xor r9d, [rdi+4]
	xor r10d, [rdi+32]		; Q' - Q
	xor r11d, [rdi+36]


;---------------Умножение Q' на x^(a-N+1)---------------;

	pop r12							; Достаем x^(a-N+1)
	mov eax, r12d					; Потребуется его копия

	Multiply

	mov r10d, r14d					; помещаем Q' * x^(a-N+1) вместо Q'
	mov r11d, r15d
	

;---------------Вычисление P' - Q' * x^(a-N+1)---------------;

	xor r10d, r8d					; записываем результат на место Q' * x^(a-N+1),
	xor r11d, r9d					; P нам ещё понадобится


;---------------Умножение P' - Q' * x^(a-N+1) на (1 - x^(a-b))^(-1) = Db----------------;

	pop r13							; Достаем (1 - x^(a-b))^(-1)
	mov eax, r13d					; Потребуется его копия

	Multiply

	pop r10							; достаём b
	mov rax, 32						; найдём необходимый сдвиг
	push rdx						; mul меняет rdx, но у меня больше нет свободных регистров
	mul r10							; приходится помещать rdx в стэк
	pop rdx	
	add rax, rbx					; считаем позицию Db
	add rax, plus					; переходим к нужному слову внутри Db
	mov [rax], r14d					; помещаем (P' - Q' * x^(a-N+1)) * (1 - x^(a-b))^(-1) = Db
	mov [rax + 4], r15d				; на место Db


;---------------Рассчет Da = P' - Db----------------;

	xor r8d, r14d					; вычисляем Da
	xor r9d, r15d
	
	pop r11							; достаём a
	mov rax, 32						; найдём необходимый сдвиг
	push rdx						; mul меняет rdx, но у меня больше нет свободных регистров
	mul r11							; приходится помещать rdx в стэк
	pop rdx
	add rax, rbx					; считаем позицию Da
	add rax, plus					; переходим к нужному слову внутри Da
	mov [rax], r8d					; помещаем Da на место Da
	mov [rax + 4], r9d

ENDM


; -------------------------------------------------------------------------------------	;
; void CalculateSyndromes(void *D, unsigned int N)										;
;	Вычисление синдромов P и Q															;
;	D - Адрес страйпа, N - количество дисков данных										;
; -------------------------------------------------------------------------------------	;

CalculateSyndromes PROC		; [RCX] - D
							; RDX   - N

;---------------Сохранение регистров---------------;

	push rdi				; сохранение регистров, которые будут использоваться
	push rsi				
	push rbx		


;---------------Вычисление P-----------------;

	mov rsi, rcx			; сохранение адреса страйпа
	mov rcx, rdx     		; rcx станет счётчиком в следующем цикле, 
	dec rcx					; нам необходимы N - 1 итерация

	mov r8, [rsi]			; в rsi записан адрес первой ячейки блоков данных;
	mov r9, [rsi+8]			; запишем регистры r8-r11 первое слово,
	mov r10, [rsi+16]		; ведь операция xor не может принять два аргумента типа mem;
	mov r11, [rsi+24]		; размер блока данных - 32, а регистра - 8,
							; поэтому разбиваем блок на 4 части
							; операция xor действует одинаково для любых полей Галуа, 
							; так как не учитывает перенос, поэтому можно разбивать на 8-байтные части,
							; хотя многочлены в моём поле должны быть 4-байтными

	mov rbx, rsi			; с помощью rbx будем перемещаться по блокам
	add rbx, 32				; сразу перейдём ко второму блоку

l1:							; в данном цикле вычисляется синдром P
		xor r8, [rbx]		; производим сложение блока по частям
		xor r9, [rbx+8]		; работаем в поле Галуа, поэтому сложение через xor
		xor r10, [rbx+16]	
		xor r11, [rbx+24]	

		add rbx, 32			; перемещаемся на следующий блок данных

		loop l1				; окончание цикла, проверка счётчика rcx

	mov [rbx], r8			; записываем P сразу за последним блоком данных 
	mov [rbx+8], r9					
	mov [rbx+16], r10				
	mov [rbx+24], r11				


;---------------Вычисление Q---------------;
	
	push r12				; в моём поле Галуа степень многочлена - 32,
	push r13				; потому для умножения приходится использовать 32-битные регистры
	push r14				; чтобы параллельно обрабатывать сразу всё слово, использую 8 регистров
	push r15				; позже значения регистров r12d-r15d будут восстановлены

	mov r8d, [rsi]			; запишем первый блок данных в регистры r8d-r15d
	mov r9d, [rsi+4]
	mov r10d, [rsi+8]
	mov r11d, [rsi+12]
	mov r12d, [rsi+16]
	mov r13d, [rsi+20]
	mov r14d, [rsi+24]
	mov r15d, [rsi+28]
	
	mov rbx, rsi			; снова устанавливаем вспомогательный регистр для перемещения по блокам
	add rbx, 32

	mov rcx, rdx     		; снова устанавливаем счётчик на N - 1
	dec rcx	

	mov edi, 0000008Dh		; записываем порождающий многочлен в edi

l2:							; в данном цикле вычисляется значение Q
		sal r8d, 1			; делаем сдвиг влево
		jnc c1				; если старший бит был = 0 (CF=0), перепрыгиваем следующую команду
		xor r8d, edi		; сложить с порождающим многочленом
	c1:
		sal r9d, 1			; повторить предыдущие 3 команды для r9d-r15d
		jnc c2
		xor r9d, edi
	c2:
		sal r10d, 1
		jnc c3
		xor r10d, edi
	c3:
		sal r11d, 1
		jnc c4
		xor r11d, edi
	c4:
		sal r12d, 1
		jnc c5
		xor r12d, edi
	c5:
		sal r13d, 1
		jnc c6
		xor r13d, edi
	c6:
		sal r14d, 1
		jnc c7
		xor r14d, edi
	c7:
		sal r15d, 1
		jnc c8
		xor r15d, edi
	c8:

		xor r8d, [rbx]		; складываем со следующим блоком данных
		xor r9d, [rbx+4]		
		xor r10d, [rbx+8]		
		xor r11d, [rbx+12]
		xor r12d, [rbx+16]	
		xor r13d, [rbx+20]
		xor r14d, [rbx+24]
		xor r15d, [rbx+28]

		add rbx, 32			; перемещаемся дальше по списку блоков данных

		loop l2				

	mov [rbx+32], r8d		; записываем Q сразу за P 
	mov [rbx+36], r9d					
	mov [rbx+40], r10d				
	mov [rbx+44], r11d
	mov [rbx+48], r12d
	mov [rbx+52], r13d
	mov [rbx+56], r14d
	mov [rbx+60], r15d


;---------------Восстановление регистров---------------;

	mov rcx, rsi
	
	pop r15					
	pop r14
	pop r13
	pop r12
	pop rbx
	pop rsi		
	pop rdi

	ret						
CalculateSyndromes ENDP

; -------------------------------------------------------------------------------------	;
; void Recover(void *D, unsigned int N, unsigned int a, unsigned int b)					;
;	Восстановление блоков с номерами a и b (b>a)										;
;	D - Адрес страйпа, N - количество дисков данных										;
; -------------------------------------------------------------------------------------	;
Recover PROC	; [RCX] - D
				; RDX   - N
				; R8	- a
				; R9	- b


;---------------Сохранем регистры и запишем порождающий многочлен---------------;

 	push rbx
	push rdi
	push rsi	
	push r12				
	push r13				
	push r14				
	push r15
	push r8
	push r9

	mov r12, rdx			; временно сохраню rdx в r12

	mov esi, 0000008Dh		; порождающий многочлен


;---------------Достаю из таблицы элемент (1 - x^(a-b))^(-1)---------------;

	mov r10, r9						; считаем значение b - a, чтобы узнать номер элемента
	sub r10, r8						; в таблице dividerTable

	dec r10							; надо перепрыгнуть (b-a) - 1 элементов, чтобы добраться до значения (1 - x^(a-b))^(-1)
	mov rax, 4						; размер элемента - 4 байта
	mul r10							; получаем количество ячеек памяти, кот. надо перепрыгнуть

	mov r11, offset dividerTable	; находим адрес первого элемента в таблице 
	mov edi, [r11 + rax]			; загружаем нужный нам элемент
	push rdi						; кладём элемент в стек, позже он нам понадобится


;---------------Достаю из таблицы элемент x^(a-N+1)---------------;

	mov r10, r12					; считем значение N - 1 - a, чтобы узнать номер элемента
	dec r10							; в таблице degreeTable
	sub r10, r8						
	
	dec r10							; надо перепрыгнуть (N-1-a) - 1 элементов, чтобы добраться до значения x^(a-N+1)
	mov rax, 4						; размер элемента - 4 байта
	mul r10							; получаем количество ячеек памяти, кот. надо перепрыгнуть

	mov r11, offset degreeTable		; находим адрес первого элемента в таблице 
	mov edi, [r11 + rax]			; загружаем нужный нам элемент
	push rdi						; кладём элемент в стек, позже он нам понадобится


;----------------Некоторые сохранения---------------;

	mov rbx, rcx			; rcx станет счётчиком, поэтому сохраним адрес D в rbx
	mov rdi, rcx			; rdi будет перемещаться по памяти
	mov rdx, r12			; вернём N в rdx, всё равно дальше придётся использовать все регистры
	

;--------------------Рассчёт Da и Db--------------------;


	CountDaDb 0

	push r11			; убираем a
 	push r10			; убираем b
	push r13			; убираем (1 - x^(a-b))^(-1)
	push r12			; убираем x^(a-N+1)

	CountDaDb 8

	push r11			; убираем a
 	push r10			; убираем b
	push r13			; убираем (1 - x^(a-b))^(-1)
	push r12			; убираем x^(a-N+1)

	CountDaDb 16

	push r11			; убираем a
 	push r10			; убираем b
	push r13			; убираем (1 - x^(a-b))^(-1)
	push r12			; убираем x^(a-N+1)

	CountDaDb 24


;---------------Восстановление регистров---------------;

	pop r15						; восстанавливаем регистры
	pop r14 
	pop r13
	pop r12
	pop rsi
	pop rdi
	pop rbx

	ret
Recover ENDP
END



